1. I compiled randall by running `make`, which produced the `randall` object
file. Next, I created a new shell script, `tests`, which runs randall and
compares the output to the expected output. After running `chmod +x tests` to
allow for execution of this shell script, I began writing the `check` target in
the Makefile. To this end, I first added `check` as a .PHONY target in the
Makefile, and then added a line that calls the `tests` script. Now, the command
`make check` runs randall with an argument of 27 and checks to see if randall
does indeed output 27 random bytes.

2. I moved the hardware-based RNG implementation to rand64-hw.c, and included
the associated function prototypes in rand64-hw.h. I took care to only include
header files which were necessary, which in this case turned out to be:
    * rand64-hw.h:
        stdbool.h
    * rand64-hw.c:
        cpuid.h
        immintrin.h
        rand64-hw.h

3. I moved the hardware-based RNG implementation to rand64-sw.c, and included
the associated function prototypes in rand64-sw.h. I took care to only include
header files which were necessary, which in this case turned out to be:   
    * rand64-sw.c:
        stdio.h
        stdlib.h
        rand64-sw.h

4. I moved the output implementation (writebytes) to output.c and included the
associated function prototype in output.h. I took care to only include header
files which were necessary, which in this case turned out to be:
    * output.h:
        stdbool.h
    * output.c:
        errno.h
        limits.h
        stdio.h
        stdlib.h
        string.h
        unistd.h
        output.h
        mrand_rand64.h
        rand64-hw.h
        rand64-sw.h

5. I edited the Makefile so that running `make` links compiles the new .c files
correctly, and ran `make check` to ensure that randall still returned expected
outputs.

6. I modified randall.c to conditionally validate the command line inputs that
are passed into randall, and to throw errors or initialize modules accordingly.

7. I implemented the parser() function in options.c, which uses getopt to parse
command line options. I defined a struct options in options.h, which contains
metainformation about the command line options that are passed into randall.

8. I created two new files, mrand_rand64.c/h, which handle the `-i mrand48_r`
command line option, i.e., random number generation using GNU's mrand48_r
function. I then included mrand_rand64.h in randall.c.

9. I moved the code that handles output from main() in randall.c to a new
function, output() in output.c.

10. I modified the writebytes() function in output.c to handle the `-o N` 
option, i.e., write N random bytes at a time using the write syscall instead of 
writing to stdio using putchar().

11. I modified the Makefile to correctly link and compile the various source
files that I created, and modified the submission-files variable in the Makefile
to ensure that the right files went into randall-submission.txz.

12. I wrote a few more tests for `make check`, which I added to the tests shell
script in the root folder.



Results of timing calls to randall:

$ time ./randall 133562368 >/dev/null
real    0m2.630s
user    0m2.630s
sys     0m0.000s

$ time ./randall 133562368 | cat >/dev/null
real    0m3.405s
user    0m3.085s
sys     0m1.392s

$ time ./randall 133562368 >rand.data
real    0m3.094s
user    0m2.921s
sys     0m0.170s
